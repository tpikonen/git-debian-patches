#!/bin/sh
set -e

patchdir="debian/patches"
metadir="debian/metapatches"
seriesfile="${patchdir}/series"
prefix="p/"
pext=".patch"
debbranch="master"
upbranch="upstream"

# Recreate patches from a git branch and metapatch files.
refresh ()
{
    dh_testdir
    rm -f ${patchdir}/debian-changes-*
    rm -f $seriesfile
    i=1
    for metafile in ${metadir}/*
    do
        patchname=$(basename $metafile)
        branch=$(sed -n 's/X-git-branch: *\(.*\)$/\1/p' $metafile)
        outfile=${patchdir}/${patchname}${pext}
        i=$(expr ${i} + 1)
        rm -f ${outfile}
        if git diff --quiet ${upbranch}..${branch} ; then
            echo "$branch is empty."
        else
            cat $metafile > $outfile
            echo "---" >> $outfile
            git diff -p --stat ${upbranch}..${branch} >> $outfile
            echo ${patchname}${pext} >> $seriesfile
            printf "%-30s -> %s\n" $branch $outfile
        fi
    done
}


# build
# Refresh the patches and build the sources with debuild.
build ()
{
    dh_testdir
    refresh
    debuild
}


# tag-heads [$VERSION]
# Tag current git branch heads with the (debian) version.
# If $VERSION is not given, get it from debian/changelog.
# Tag for the debian branch (usually 'master') has the name debian/$VERSION,
# patch branch tags are tagged with the name $PATCHBRANCH/$VERSION
tagheads ()
{
    dh_testdir
    version=$1
    # FIXME: Check if the version string makes sense
    if [ -z ${version} ] && [ "${version+xxx}" = "xxx" ] ; then
        version=$(dpkg-parsechangelog | sed -n 's/^Version: \(.*\)$/\1/p')
    fi
    i=1
    for metafile in ${metadir}/*
    do
        branch=$(sed -n 's/X-git-branch: *\(.*\)$/\1/p' $metafile)
        echo "Tagging ${branch} with ${branch}/${version}"
        git tag ${branch}/${version} ${branch}
    done
    echo "Tagging ${debbranch} with debian/${version}"
    git tag debian/${version} ${debbranch}
}


# import-orig tarballname
# Import the tarball to $debbranch and pristine-tar branches,
# but do not merge the to master
importorig ()
{
    dh_testdir
    tball=$1
    git import-orig --no-merge --pristine-tar --upstream-branch=${upbranch} ${tball}
}


# newpatch patchname
# Create a new patch branch branching from current upstream and
# start the editor with a partially filled DEP-3 header in $metadir
newpatch ()
{
    dh_testdir
    patchname=$1
    if [ ${#patchname} -lt 1 ] ; then
        echo "You must give a patch name."
        exit 1
    fi
    if [ ! -d $metadir ] ; then
        if [ -e $metadir ] ; then
            echo "Error: $metadir exists, but is not a directory."
            exit 1
        fi
        mkdir -p $metadir
    fi
    npatches=$(ls $metadir | wc -l)
    pnum=$(expr $npatches + 1)
    echo "You have $npatches patches."
    branchname=${prefix}${patchname}
    echo "Creating a new branch $branchname ..."
    git branch $branchname $upbranch
    metaname=$(printf "%s/%02d_%s" $metadir $pnum $patchname)
    echo "Creating metapatch $metaname ..."
    cat > $metaname << EOF_really
From: $DEBFULLNAME <$DEBEMAIL>
Subject: 
X-git-branch: $branchname
EOF_really
    echo "Launching $EDITOR $metaname ..."
    $EDITOR $metaname
}


# pick patchbranch <commit-ish>
# Cherry-pick a given commit to a patchbranch.
pick ()
{
    echo $#
    if [ $# -lt 2 ] ; then
        echo "You must give a patch branch name and a commit."
        exit 1
    fi
    branch=$(git rev-parse --symbolic --verify $1 2> /dev/null) \
        || (echo "$1 is not a valid branch." ; exit 1)
    commit=$(git rev-parse --verify $2 2> /dev/null) \
        || (echo "$2 is not a valid commit." ; exit 1)
    currbranch=$(git symbolic-ref HEAD)
    currbranch=${currbranch##refs/heads/}
    git checkout $branch
    git cherry-pick $commit
    git checkout $currbranch
}


PROGNAME=$(basename $0)
case $1 in
    refresh)
        shift ; refresh ;;
    build)
        shift ; build ;;
    tag-heads)
        shift ; tagheads $@ ;;
    import-orig)
        shift ; importorig $@ ;;
    new-patch)
        shift ; newpatch $@ ;;
    pick)
        shift ; pick $@ ;;
    *)
        echo "$PROGNAME: Error: Unknown subcommand." >&2
        exit 1 ;;
esac

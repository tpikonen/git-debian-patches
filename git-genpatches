#!/usr/bin/env python
"""Create a series of patches to take a branch to another through a number
of feature branches.

Usage: %(program)s [ --patchdir=<dir> | -p <dir> ]
                   [ --exclude <pattern> | -x <pattern> ]
                   [ --series ]
                   --base <commit-ish> --int <commit-ish> [ <commit-ish> ... ]

Options: 
    -b|--base <commit-ish> Commit to base the patches to. Default 'upstream'.
    -i|--int <commit-ish> Commit ending the patch stack. Default 'debian'.
    -p|--patchdir <dir> Directory where patches are stored. 
        Default 'debian/patches'.
    -x|--exclude <pattern> Exclude pattern fed to 'filterdiff -x'. 
        You can specify more patterns by giving this option more than once.
    -s|--series Write out a quilt type series file to patchdir.
"""

# Author: Teemu Ikonen <tpikonen@gmail.com>
# This program is in public domain

import os,sys,warnings,getopt,shutil,subprocess,fnmatch

program = sys.argv[0]
warnings.simplefilter('ignore', RuntimeWarning)

def usage(code, msg=''):
    print >> sys.stderr, __doc__ % globals()
    if msg:
        print >> sys.stderr, msg
    sys.exit(code)

def frob(cmd):
    print cmd
    return os.system(cmd)

def getrefs():
    cmd = r"git-show-ref | sed -e 's,.*refs/[^ /]*/\([^ ]*\).*,\1,'"
    print cmd
    f = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout
    refs = [line.strip() for line in f.readlines() ]
    f.close()
    return refs

def iscommit(name):
    if len(name) == 0:
        return False
    cmd = "git-name-rev " + name
    print cmd
    f = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout
    output = f.readline()
    f.close()
    if len(output) > 0:
        return True
    else:
        return False

def checkref(name):
    if not iscommit(name):
        usage(1, "'" + name + "' is not a valid commit")

def gitdiff(b1, b2, pname, exlist):
    ex = ""
    if exlist:
        ex = " | filterdiff " + reduce(lambda x,y: x + " -x " + y, exlist, "")
    cmd = "git diff "+ b1 + ".." + b2 + " | filterdiff" + ex + " > " + pname
    return frob(cmd)

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hb:i:p:x:s", \
        ["help", "base", "int", "patchdir=", "exclude=", "series"])
    except getopt.GetoptError, err:
        usage(2, err.msg)
    base = "upstream"
    intg = "debian"
    patchdir = "debian/patches/"
    exlist = []
    series = False
    for o, a in opts:
        if o in ("-h", "--help"):
            usage(0)
        elif o in ("-b", "--base"):
            base = a
        elif o in ("-i", "--int"):
            intg = a
        elif o in ("-p", "--patchdir"):
            patchdir = a
        elif o in ("-x", "--exclude"):
            exlist.append(a)
        elif o in ("-s", "--series"):
            series = True
        else:
            assert False, "unhandled option"

    if not os.path.isdir(patchdir):
        usage(1, "Output directory", patchdir, "not found, exiting...")
    patchdir = patchdir + "/"

    checkref(base)
    checkref(intg)

    allrefs = getrefs()
    frefs = []
    for name in args:
        l = fnmatch.filter(allrefs, name)
        if l:
            frefs = frefs + l
        elif iscommit(name):
            frefs.append(name)
        else:
            usage(1, "Could not match '" + name + "' to a ref.")
    frefs = sorted(list(set(frefs)))
    npatches = len(frefs)

    cmd = 'git stash save "Local changes saved by git-genpatches"'
    frob(cmd)
    
    tmpbranch = os.path.basename(os.tempnam())
    cmd = "git checkout -b " + tmpbranch + " " + base
    frob(cmd)

    fpatches = []
    revpatches = [];    
    if npatches > 0:
        fpatches.append(os.tempnam())
        gitdiff(base, frefs[0], fpatches[0], exlist)
    for i in range(1,npatches):
        fpatches.append(os.tempnam())
        gitdiff(base, frefs[i], fpatches[i], exlist)
        tname = os.tempnam()
        cmd = "minrevert -o " + tname + " " + fpatches[i-1] + " " + fpatches[i]
        frob(cmd)
        try:
            s = os.stat(tname)
            if s.st_size > 0:
                revpatches.append(tname)
            else:
                revpatches.append("")                
                os.remove(tname)
        except:
            revpatches.append("")

    #print fpatches
    #print revpatches
#    tmpdir = os.tempnam()
#    os.makedirs(tmpdir)
#    tmpdir = tmpdir + "/"

    pno = 1
    patchnames = []
    def movefeat(i, n):
        patchnames.append(("%02d_" % n) + os.path.basename(frefs[i]) + ".patch")
        shutil.move(fpatches[i], patchdir + patchnames[n-1])
    def moverev(i, n):
        patchnames.append(("%02d_" % n) + "conflicts" + ".patch")
        shutil.move(revpatches[i], patchdir + patchnames[n-1])        
    if npatches > 0:
        movefeat(0, pno)
    pno = pno+1
    for i in range(1,npatches):
        if len(revpatches[i-1]) > 0:
            moverev(i-1, pno)
            pno = pno+1
        movefeat(i, pno)
        pno = pno+1
    
    for patch in patchnames:
        cmd = "git apply --index " + patchdir + patch
        frob(cmd)
    
    cmd = "git commit -m 'Feature patches applied'"
    frob(cmd)

    patchnames.append(("%02d_" % pno) + "rest" + ".patch")

    gitdiff("HEAD", intg, patchdir + patchnames[pno-1], exlist)
    cmd = "git apply --index " + patchdir + patchnames[pno-1]
    frob(cmd)
    cmd = "git commit -m 'Rest patch applied'"
    frob(cmd)

    cmd = "git diff HEAD.." + intg + " | filterdiff | filterdiff " + reduce(lambda x,y: x + " -x " + y, exlist, "") + " | wc -l"
    status = frob(cmd)
    print "diff exit code: " + str(status)
    #if status > 255:
#    print "Found differences not representable in the final patch, exiting."
#    sys.exit(1)

    if series:
        f = open(patchdir + "series", "w")
        for p in patchnames:
            f.write(p + "\n")
        f.close()

    cmd = "git checkout " + intg
    frob(cmd)
    cmd = "git branch -D " + tmpbranch
    frob(cmd)

    
if __name__ == "__main__":
    main()
        

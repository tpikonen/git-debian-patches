#!/usr/bin/env python
# Copyright (C) 2008-2013 by Teemu Ikonen <tpikonen@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import os, sys, shutil, subprocess, fnmatch, re, random, string, warnings
import logging
from optparse import OptionParser

description="""\
Create a series of patches to take a branch to another through a number
of feature branches."""

usage="%prog [options] <commit-ish> ... "


def frob(cmd):
    logging.debug("Running: %s" % cmd)
    f = subprocess.Popen(cmd, shell=True, stderr=subprocess.STDOUT,
                         stdout=subprocess.PIPE).stdout
    logging.debug("    Got: %s" % f.readlines())
    f.close()
    #subprocess.check_call(cmd, shell=True)
    return None


def getrefs():
    cmd = r"git show-ref | sed -e 's,.*refs/[^ /]*/\([^ ]*\).*,\1,'"
    logging.debug("Running: %s" % cmd)
    f = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout
    refs = [line.strip() for line in f.readlines() ]
    f.close()
    logging.debug("    Got: %s" % refs)
    return refs


def iscommit(name):
    if len(name) == 0:
        return False
    cmd = "git name-rev " + name
    logging.debug("Running: %s" % cmd)
    f = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
                        stderr=open(os.devnull, 'w') ).stdout
    output = f.readline()
    f.close()
    logging.debug("    Got: %s" % output)
    if len(output) > 0:
        return True
    else:
        return False


def temp_branchname():
    """Return a temporary branchname which does not exist."""
    def randstr(N):
        return ''.join(random.choice(string.ascii_lowercase + string.digits)
            for i in xrange(N))

    bname = 'branch_' + randstr(6)
    while(iscommit(bname)):
        bname = 'branch_' + randstr(6)
    return bname


def gitdiff(b1, b2, pname, exlist, diffargs="-p --stat ", debug=True):
    # 'git diff' has no -x option and I want to cry.
    filescmd="(git ls-tree -r --name-only %s ; git ls-tree -r --name-only %s) | sort | uniq" % (b1, b2)
    grep_pattern = "-e '"+"' -e '".join(exlist)+"'"
    # pattern '(?!x)x' always matches.
    cmd = "git diff "+diffargs+" "+b1+".."+b2+" -- `"+filescmd+" | grep -v --regexp='(?!x)x' "+grep_pattern+"` > "+pname
    logging.debug("Running: %s" % cmd)
    return subprocess.call(cmd, shell=True)


def is_okdiff(fname, branchname):
    s = os.stat(fname)
    if s.st_size > 0:
        return True
    else:
        logging.warning('\n\n\n   Branch %s is empty!\n\n\n' % branchname)
        return False


def get_metadata(metadir):
    allfiles = os.listdir(metadir)
    allfiles.sort()
    branches = []
    metafiles = []
    for fname in allfiles:
        with open(metadir + '/' + fname) as ff:
            match = re.search("^X-git-branch: *(.*)$", ff.read(), re.MULTILINE)
        if match:
            branches.append(match.group(1))
            metafiles.append(metadir+'/'+fname)
            logging.info("Found metafile: %s" % metafiles[-1])
    return metafiles, branches


def main():
    default_base = "upstream"
    default_dest = "master"
    default_patchdir = "debian/patches/"
    oprs = OptionParser(usage=usage, description=description)
    oprs.add_option("-b", "--base", type="string", dest="base", \
        default=default_base, metavar="<commit-ish>", \
        help="Commit to base the patches to. Default '%s'." % default_base)
    oprs.add_option("-d", "--dest", type="string", dest="dest", \
        default=default_dest, metavar="<commit-ish>", \
        help="Commit ending the patch stack. Default '%s'." % default_dest)
    oprs.add_option("-p", "--patchdir", type="string", dest="patchdir", \
        default=default_patchdir, metavar="<dir>", \
        help="Directory where patches are stored. Default '%s'." \
            % default_patchdir)
    oprs.add_option("-x", "--exclude", action="append", default=[], \
        dest="exclude", metavar="<regexp>", \
        help="Files matching this regexp will be filtered out from generated\
 patches. You can give this option more than once.")
    oprs.add_option("-s", "--series", action="store_true", dest="series", \
        default=False,\
        help="Write out a quilt type series file to patchdir.")
    oprs.add_option("-m", "--metadir", type="string", dest="metadir", \
        default=None, \
        help="Get branch names from metapatches in this directory.")
    oprs.add_option("-v", "--verbose", action="count", dest="verbosity", \
        default=0, \
        help="Increase verbosity. Use two times for debug output.")
    (opts, args) = oprs.parse_args()
    logging.basicConfig(level=max(0, 30 - 10*opts.verbosity),
                        format="%(levelname)s: %(message)s")
    logging.debug("Starting up.")
    if not os.path.isdir(opts.patchdir):
        oprs.error("Output directory "+opts.patchdir+" not found.")
    patchdir = opts.patchdir + "/"
    base = opts.base
    dest = opts.dest
    series = opts.series

    warnings.filterwarnings("ignore", "tempnam")

    if not iscommit(base):
        oprs.error("'" + base + "' is not a valid commit")
    logging.info("Base branch: %s" % base)
    if not iscommit(dest):
        oprs.error("'" + dest + "' is not a valid commit")
    logging.info("Dest branch: %s" % dest)
    if opts.metadir:
        metafiles, branchnames = get_metadata(opts.metadir)
    else:
        branchnames = args
        metafiles = [ None for b in branchnames ]
    logging.info("Creating patches for branches: %s" % ' '.join(branchnames))
    logging.info("Writing patches to: %s" % patchdir)
    if opts.exclude:
        map(lambda s: logging.info("Excluding files matching: %s" % s),
            opts.exclude)

    allrefs = getrefs()
    frefs = []
    for name in branchnames:
        l = fnmatch.filter(allrefs, name) # FIXME: Use git rev-parse?
        if l:
            frefs = frefs + l
        elif iscommit(name):
            frefs.append(name)
        else:
            oprs.error("Could not match '"+name+"' to a ref.")
    if len(frefs) != len(set(frefs)):
        oprs.error("Repeated patch branches given")
    npatches = len(frefs)

    cmd = 'git stash save "Local changes saved by git-genpatches"'
    frob(cmd)

    tmpbranch = temp_branchname()
    logging.info("Using temporary branch %s" % tmpbranch)
    cmd = "git checkout -b " + tmpbranch + " " + base
    frob(cmd)

    fpatches = []
    revpatches = [];
    if npatches > 0:
        logging.info("Processing branch %s" % frefs[0])
        fpatches.append(os.tempnam())
        gitdiff(base, frefs[0], fpatches[0], opts.exclude)
        if is_okdiff(fpatches[0], frefs[0]):
            cmd = "git apply --index " + fpatches[0]
            frob(cmd)
            cmd = "git commit -m '0'"
            frob(cmd)
    currstate = os.tempnam()
    for i in range(1,npatches):
        logging.info("Processing branch %s" % frefs[i])
        fpatches.append(os.tempnam())
        gitdiff(base, frefs[i], fpatches[i], opts.exclude)
        if not is_okdiff(fpatches[i], frefs[i]):
            revpatches.append("")
            continue
        gitdiff(base, tmpbranch, currstate, opts.exclude)
        tname = os.tempnam()
        cmd = "conflictdiff -r -o "+tname+" "+currstate+" "+fpatches[i]
        frob(cmd)
        try:
            s = os.stat(tname)
            if s.st_size > 0:
                logging.info("    Revert patch needed")
                revpatches.append(tname)
                cmd = "git apply --index " + tname
                frob(cmd)
                cmd = "git commit -m 'Revert patch'"
                frob(cmd)
            else:
                revpatches.append("")
                os.remove(tname)
        except:
            revpatches.append("")
        cmd = "git apply --index " + fpatches[i]
        frob(cmd)
        cmd = "git commit -m '%d'" % i
        frob(cmd)

    gitdiff(base, tmpbranch, currstate, opts.exclude)
    fullpatch = os.tempnam()
    gitdiff(tmpbranch, dest, fullpatch, opts.exclude)
    restname = os.tempnam()
    cmd = "conflictdiff %s %s | filterdiff > %s" \
        % (fullpatch, currstate, restname)
    frob(cmd)
    os.remove(currstate)
    os.remove(fullpatch)
    have_respatch = os.stat(restname).st_size > 0
    if have_respatch:
        logging.info("Creating a resolution patch.")
        cmd = "git apply --index " + restname
        frob(cmd)
        cmd = "git commit -m 'Rest patch applied'"
        frob(cmd)

    cmd = "git checkout " + dest
    frob(cmd)

    seriesfile = patchdir + "series"
    if os.path.isfile(seriesfile):
        logging.info("Removing files from previous seriesfile %s" % seriesfile)
        with open(patchdir + "series") as fs:
            for line in fs:
                try:
                    filename = patchdir + line.rstrip()
                    os.remove(filename)
                except OSError:
                    logging.debug("File '%s' does not exist." % filename)
                    pass

    def append(srcname, dstname):
        with open(srcname, 'r') as fsrc:
            with open(dstname, 'a') as fdst:
                fdst.write('\n')
                shutil.copyfileobj(fsrc, fdst)

    def movefeat(i, n, metafile=None):
        pname = "%02d_%s.patch" % (n, os.path.basename(frefs[i]))
        print("Writing patch %s" % pname)
        patchnames.append(pname)
        if metafile:
            shutil.copy(metafile, patchdir + pname)
        append(fpatches[i], patchdir + pname)
        os.remove(fpatches[i])

    def moverev(i, n):
        pname = "%02d_CONFLICTS_IN_%s.patch"%(n, os.path.basename(frefs[i+1]))
        print("Writing patch %s" % pname)
        patchnames.append(pname)
        shutil.move(revpatches[i], patchdir + pname)

    pno = 1
    patchnames = []
    if npatches > 0:
        movefeat(0, pno, metafiles[0])
    pno = pno+1
    for i in range(1,npatches):
        if len(revpatches[i-1]) > 0:
            moverev(i-1, pno)
            pno = pno+1
        movefeat(i, pno, metafiles[i])
        pno = pno+1

    if have_respatch:
        pname = ("%02d_" % pno) + "RESOLUTION.patch"
        print("Writing patch %s" % pname)
        patchnames.append(pname)
        with open(patchdir + pname, 'w') as ff:
            ff.write("Resolve patch overlaps.\n")
            with open(restname, 'r') as fp:
                shutil.copyfileobj(fp, ff)
    os.remove(restname)

    status = gitdiff("HEAD", dest, "/dev/null", opts.exclude, "--quiet")
    if status > 0:
        logging.error("Found differences not representable in the final patch!")

    if series:
        print("Writing series file to %s" % patchdir + "series")
        f = open(patchdir + "series", "w")
        for p in patchnames:
            f.write(p + "\n")
        f.close()

    cmd = "git branch -D " + tmpbranch
    frob(cmd)


if __name__ == "__main__":
    main()
